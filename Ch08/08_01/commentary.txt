- When you want to do more than just serve static files, you will need to choose a framework that supports more functionality. In this next chapter, we are going to be taking a look at the Express framework. Express is a very popular framework for developing web server applications. From the npmjs.com registry, I am going to go and search for the Express package. And we can see it is the first package that shows up in this drop down, so I will select it and this will take me to the homepage for the express project in npmjs.com.

Express is the most popular node.js framework. It was inspired by Sinatra, a rails based web server framework and express also represents the e in the MEAN stack. Express is usually the first framework that node.js developers are introduced to. You are highly likely to come across a web server application built in Express or a project with Express as an requirement in your day to day work as a node.js developer. Let's go ahead and get started with this project. It will take us several lessons to get through this project.

In this lesson, we are going to focus on getting our project started by creating a package.json. If you navigate to your exercise files, you will notice that under chapter 08 lesson 01, in the start folder, there is a public folder that has the client side files for the application that we are going to build already there. So, you will need this public folder to get started and then we will iterate around this public folder to actually build the server version of the app. The very first thing that we need to do is we need to create a package.json file.

A package.json file is a manifest that contains information about our app. It will allow us to easily distribute our application code without having to worry about distributing all the dependencies as well. Let's go to our Terminal and under our Terminal I can actually create a package.json with an npm tool, npm init. So, npm init will start to build this package.json file for me. The first thing it wants to know is the name of your application or library. The application that we are going to build is a dictionary application and in this dictionary I'm going to define some skier terms.

You can feel free to define whatever your favorite hobbies, terms might be in your dictionary. When I name this application, I'm going to call it the ski-dictionary. Now, when I name a package or a library, I have to restrict the package name to being lowercase only and we can't use spaces. If I want to use a space, we tend to use dashes instead. So, instead of using ski dictionary, we will call this package ski-dictionary. I will go ahead and start this off as version 1.0.0 and in the description we can define what this application is.

A collection of skier terms and definitions. And the entry point represents the node.js file that we should start to run the app. By default, they want this to be index.js. We are going to have a file called app.js that will be our entry point. We will add the test command later so you can just skip that now. If you have a git repository that could be added here. The npm init will automatically pick up a git repository if you have a git folder in the root of your project.

For keywords, we can add a comma delimited list of words to help us find this package if we choose to publish it on the npm registry. The keywords I will add are ski, terms, and dictionary. We separate them by commas and we have a comma delimited list of keywords. I am the author. You should add yourself to the author node and then we can select a license. We could set this as closed source, but I am just going to go ahead and select the MIT license for this application.

Then it will echo back the package.json file that it is about to build for you. The package.json file is just a json file. You can get in there and code this yourself. The npm init just makes it much easier to get started. I will go ahead and say yes. And once we have said yes, you can navigate to your files and what you will notice is you now have a package.json file in your start folder. If you open up that package.json file, it contains information about your project. Now you can actually get in here and add nodes and make changes to this package.json as your project continues to grow and develop.

It contains meta information about our project, but the package.json also does something very important. It will keep track of our projects dependencies. For this project we're going to be using express and along with express, we're going to be using a couple other modules to help us with the development of our application. Let's go into the Terminal and start to install these modules. The first thing I'm going to install for this project is express, npm install and we can add express and then I'm going to go ahead and add a --save flag.

The --save flag will add this dependency to my package.json file so when I installed express, I will have a reference to express in my manifest We can go ahead and install express. And I'm going to go ahead and clear the terminal screen and we're going to install a couple other node modules. Another node module that we are going to need with this project is cors. CORS stands for Cross Origin Resource Sharing and it's going to allow us to open up our api so that it is accessible by other domains.

What I'm going to go ahead and do is npm install cors and also send it a --save flag. In the last module that I'm going to install is called the body-parser. If you recall back in chapter six, we had a lesson on handling post bodies. When a form is posted to a web server, that post is usually url encoded. Sometimes it can be encoded as json, so one of the tasks that you have to do is parse the form variables. What we want to do is have a node module do that for us and the node module that we're going to use is called body-parser.

Let's just go ahead and install body-parser and also send that the --save flag. So, now I've installed three dependencies and you're going to see them all referenced within the package.json. Let's go take a look at that file. If I go over to my Finder, you will notice that we now have a node_modules folder. In the node_modules folder, I have body-parser, cors and express. If I open up my package.json file, sending the save flag has added a dependencies node on line 16.

You can see that we are dependent upon body-parser, cors and express. What is nice about this is this package.json now references the dependent packages that we're going to need for our application. This makes installing everything that we need for our application extremely easy. We've actually already have done the installs. You would need to do them again at this point, but let's take a look at something. Let's go out to our files and I'm going to delete the node_modules folder. I'm simply going to Move it to the Trash.

So now, I do not have the dependent packages that I need installed. This is exactly how we are going to pass our files around. If I we're to publish this project on github or send this project to you in a zip via email, I can't send all the dependencies. They are way too big. But I do have a package.json file and that package.json file has a listing of all the dependencies that you would need to install to make this application work. If you were to receive these files, the first thing that you would do in the terminal, I'll go ahead and clear that leftover terminal text.

So, now we do not have any packages locally installed. What we can do is run an npm install. Now, I'm not specifying a package name or anything else. When I run an npm install, npm will take a look at my package.json file and it will go ahead and install all of the dependencies at once. Simply running an npm install has installed all of the required dependencies at once. Let's go ahead and take a look at our files one last time. In our files, we now have a node_modules Folder and in our node_modules Folder we have all three dependencies reinstalled even though we removed them.

One last thing that you'd be able to do with a package.json is also install and remove dependencies from the package.json. Let's say I wanted to install underscore, I can npm install underscore and add a --save flag and this will install the underscore library locally. This will also add underscore to my package.json, so navigating back to my package.json, you can now see that we have underscore inside of this file. So, if I wanted to remove anything from my package.json all I need to do is execute an npm remove and I can also specify underscore and now I would also send the remove command a --save flag.

Sending the --save flag to the remove command means that it will also be removed from my package.json. Now I have unbuild underscore and if we go take a look at our files and look at our package.json, you will notice that we no longer have underscore. So, the package.json file is important for everyone of our node applications or libraries. It gives us a manifest of information about the package and it also keeps track of all the dependencies that this package requires.