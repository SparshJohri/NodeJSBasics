We are in the process of building a dictionary web application that will help us communicate some of our favorite defined terms. In the last lesson, we added a "get" route for the dictionary API itself, that returns an array of skier terms. Let's go ahead and see where we are with our application. I am in the Exercise files, under Chapter 8, Lesson 4 and in the Start folder you will notice that we have a Public folder, and the Public folder contains the Client files for our application which have already been coded for you. Also notice that we have a package.json but we do not have a node modules folder.

So the very first thing that I need to do is install the dependencies, because I am in a different folder. So I can do that with an npm install. And the next thing that I can do is start my app. Since I'm in the process of developing this application I'm going to use the node dev module that we installed back in Chapter 7. So node-dev app will run my app using "node-dev", which means that I don't have to get out here and restart it every time I make some changes. So I'm going to go ahead and navigate to my browser and hit "localhost.3000", where our application is running.

And when we do so, we see that we have some skier terms showing up here on the page. These terms are actually coming from "\dictionary-api", and when we look there we see that we have an array of skier terms showing up. What I'm going to do is go back to localhost.3000 and by clicking on this little hamburger menu in Google Chrome, I can come down here to More Tools and open up the Developer Tools. And when I do so, I can make sure that the Network panel is highlighted, so make sure you select the Network panel and then I can hit "Refresh" and we can see all of the network requests that this page is making.

So it's also making a XHR request for dictionary.api, that's where the terms are coming from. What happens when I add a new term? So if I add a new term for "Powder", "The good stuff, why we ski", I'm actually making a POST request of the dictionary.api, and I get a 404. Because we haven't built a route to handle POST requests. Also, look at what happens if I try to delete a term. Double-clicking on any of these terms will send a DELETE request to a route that has the exact same name as the term.

So if I go back out to my terminal, what you will notice is we have added a POST request for dictionary.api but we don't have anything handling it. And we also have a DELETE request for dictionary.api slash, the term name, but we don't have anything handling that either. So I need to go back into my exercise files and add those POST and DELETE routes. So in my exercise files I'm going to go ahead and open up app.js. So the first thing that I'm going to need to do is collect that posted data.

And back in the first lesson of this chapter, we installed all of the dependencies into our package.json. One of those dependencies was the bodyParser. We're going to need to use that now. So I'm going to go ahead and include the bodyParser into my application. The bodyParser is middleware that will help us parse the data that is posted to this API. So if we post data from my rest application, it will send data as .json. If we actually fill out a form in a web browser and POST the data, that data will be sent to us URL-encoded.

So we need to get in there and parse that POST data so that we can use those variables very neatly. What I'm going to do is add this piece of middleware above our logger here, roughly on Line 21. So I'm going to add an app.use to add the bodyParser and the first type of body that we want to parse are .json bodies. So if we have data sent to our API as .json, we will parse that data. And also we're going to use the bodyParser to make sure if the body data was sent URL-encoded that we are parsing that as well.

The URL-encoded function takes one option, "extended", which we can set to false. You will only need to set extended to true if you have large amounts of nested POST data to parse. So now that we've parsed this data, what happened? It just means that we have gone in and parsed all the variables that are posted to this application, and placed them neatly on the request object. Inside my custom piece of middleware, I'm just going to log any POST data that we might have. So if I go over here and throw in a hypen, still within my back-ticks, I'm within the string template because I'm actually going to display a variable here, I will JSON.stringify our POST data, and we can find this data on the request object.

The req.body is going to contain these variables. So I'll save this. And if we actually go out to the browser, we can go ahead and hit "Refresh". And we can see our three terms showing up there. And if I try to add a new term, "Powder," "The good stuff, why we ski", when I add this term, now I still haven't handled the POST request, but what I want to show you is what that POST data looks like. So if we go over to our terminal, you will notice that our app has restarted since we are running it with no dev, and the last request was a POST request made for dictionary.api.

And some data was sent with that POST request. The "term":"Powder" was sent, and its definition was also sent to us. So what we want to do is take that POST body data and add it to our skier terms array. I'm going to go back into my code. And I will scroll down to after the "Get" route for the dictionary.api, and I'm going to add two more routes here. So the first route that I'm going to add is our POST route. We app.post to "/dictionary-api", then we can handle any POST request to this route, with this callback function.

And this callback function will take in our request and our request will also have the POST body. And it will also take in a response. So if you've posted a term to the dictionary.api all I want to do is make sure that I push your new term into the array. So we are going to push the req.body into the array. I'm going to respond with .json the new array of (skierTerms) which will have one more term. So let's go ahead and save this, and go out to our browser and we can refresh the page, and I can go ahead and try to add "Powder".

And I do so, I can try to add "The good stuff, why we ski". And now when I add this term, we see "Powder, the good stuff, why we ski". Because my POST request is now handling the data and adding it to the array. Now the other thing that I need to do is handle a DELETE. If I tried to delete "Powder" by double-clicking on it, notice that I still have a 404 to our DELETE route. And if i go out into the terminal and take a look at that, you can see that we have made a DELETE request for dictionary.api/Powder.

What we need to do is set up a route with a routing variable for the skier term, so that we know which term you would like to delete. So I'm going to go back into my code. And right below my POST route I'm also going to add a DELETE route. And if you send a term to dictionary-api/ whatever term you send, I can set that up as a routing variable with a colon. So this means that I've just created a routing parameter called "term". The value of this variable will be whatever is found in the route after dictionary-api on a DELETE request.

And we're going to handle our DELETE request with this callback function. And of course just like every other route this will take in the (req, res) objects. So now that routing variable is going to be available to me on req.params.term. So whatever that value is will be added to this parameter variable. What I want to do is use that value to filter that term out of my dictionary. So I'm going to reset skierTerms to equal skierTerms.filter(); Now, skierTerms is a JavaScript array, and JavaScript arrays have a Filter function.

The filter function will take in a callback function. And this callback function will be invoked once for every term found in the array. I'm going to call that term the (definition). So each one of these terms is going to be passed as an argument to this callback function. And if we have three terms in this array, the filter function will fire this callback three times. This callback function is a function that we refer to as a "predicate". What that means is, it should only return "true" or "false". If it returns "true", it means that the definition should stay in the array.

If it returns "false", it means that we should remove that definition from the array. So we are going to return "true" or "false" based on a check. We only want to return "true" when the definition.term, and we will convert it toLowerCase() just to make it case-insensitive, !== the req.params.term. toLowerCase, just to make it case-insensitive. So now we are going to filter any terms out of the skier array that were sent as a routing parameter.

I'm also going to respond with my skierTerms, and this should be a new array, one value less. So I'm going to go ahead and save this, and we can go back out to Google Chrome, and this time when I hit "refresh", the application has restarted. So every time we start the application we only have these three terms in it, because we are defining our skier terms in memory. So now, if I wanted to add "Powder" again, we could do that.

We're able to POST new data. And now if I want to delete any of these terms all I need to do is double-click on the term and you can see that we have deleted the Huck term because we sent a DELETE request to the Huck route. We have deleted the Powder term, because we have sent a DELETE request to the Powder route. If I go out here and take a look at my terminal you can see that we are sending DELETE requests to those routes, and we are using that router parameter variable to filter out that term from our skier definition.

So at this point, our application seems to work. We can display dictionary terms, we can add new terms, and we can delete the terms. And our client app is getting these terms, posting these terms, and deleting these terms to our web server application via an API.