- In this next chapter, we're going to dive deep into Node.js's HTTP module. The HTTP module will be used for creating web servers, for making requests, for handling responses. There are two modules for this. There's the HTTP module and the HTTPS module. Now, both of these modules are very, very similar, but we'll only use the HTTPS module when we're working with a secure server. So that means if we want to create an HTTPS server, we would use the HTTPS module, and then we would have to supply the security certificate.

With the HTTP module, there's no need to supply a security certificate. In this next lesson, we are going to make a request with the HTTPS module, and the reason we're using the HTTPS module is we are going to make a request of Wikipedia. So you can see that this is George Washington's Wikipedia page, and it is being served via HTTPS. The domain is en.wikipedia.org, and our route is /wiki/George_Washington. Now you can find the wiki for most any famous person and all of our presidents simply by typing the name of the person...

with an underscore between their name... instead of a space, and we can look up Thomas Jefferson, George Washington, James Madison, anybody we want. So we're going to make a request for our favorite president from the Wikipedia page. So let's go into our files. Under the Start folder, there is a request.js. This is just an empty JavaScript file. So I'm going to go ahead and open that up and begin building my request. We're going to be using the HTTPS module, and that means we need to require HTTPS.

Now, if we were making a request of a server that wasn't HTTPS, we can actually just use the HTTP module and all of the code in this file will be identical. So the other thing that we're going to use is the file system, so we will require that. Now, in order to make a request with the HTTP or HTTPS module, I need an object literal of options. So these are going to be the details about my request. The first thing that we're going to need is the host name. The host is going to be en.wikipedia.org.

The second thing we're going to need is the port. Most public websites that are not served on HTTPS, their ports are usually 80. Whenever we're using an HTTPS site, the default port tends to be 443. That is not always an exact science, but in this case, we know that Wikipedia's HTTPS port is in fact 443. The next thing we need to supply is our path. That's going to be /wiki/George_Washington.

You can actually add your favorite president there. Simply separate the first and last name with an underscore as opposed to a space, and then we also need to add our request method, so we're going to be making a GET request for George Washington's Wikipedia page. I can go ahead and make the request using https.request. So the HTTPS and the HTTP module both have a request function that you can send the options for your request. We are going to make a request with the HTTPS module of the George Washington Wikipedia page.

Once our request has started, this callback function, the second argument of the request function will be invoked. It will also add our response object. Now, I said "once the request has started", because our response object actually implements the stream interface. What we're going to do with this request is we are going to get George Washington's Wikipedia page sent to us from the Wikipedia server as a stream. The first thing I'm going to do is create a variable for the response body and we will set that to an empty stream.

We're going to concatenate the details of this page into that response body variable, and we'll go ahead and add some console.logs. Will let you know that the response from the server has started. I'm also going to go ahead and log some details about the response itself, so what I want to do is actually use a template string here, then I can say Server Status, and I will go ahead and display in this template string using the res.statusCode.

This will give me the HTTP server code for our response, and then in addition to that, I'm also going to go ahead and just log our headers. This time, I'm not going to use a template string because I want to log this data as J-San, and it's pretty easy just to put in a %j in the console log and then pass the variable that you want to replace that %j. This will be our response headers. We'll take a look at those headers there as well. Now, the other thing on this stream, by default the encoding will be binary, so I want to actually set that encoding to UTF-8, so this will make sure that the stream will come in as text.

The very first time this response raises a data event, this callback function will fire, and these data events are going to represent our data streams, so each chunk of data will be passed as an argument to our callback function. So what I want to do is just log the chunk. The very first chunk, we're just going to log it, just to see what one chunk of data looks like. For every data event, I'm going to actually add a listener on the response object for any data event, and I'm going to go ahead and add this callback function here, so every data event will also pass us a chunk of data.

This chunk of data is going to be a text chunk, so what I want to do is just log its length. To do that, I am going to use a template string, so our backtick characters in, just go ahead and put the word "chunk" out there, and then we will also log the chunk's length. So the very first data event, we will see the length for the chunk, but then we will actually see what one chunk looks like. For every data event, we're going to see the length of a chunk. And then finally, we also need to concatenate our response body.

Our response body is going to += each chunk of data. Great. Then finally, we need to listen for when this response has ended, so response on "end". We can invoke this callback function. There we go. Once the response is over, we're actually just going to write all of this data to a file. I will use that fs.writeFile method, and we are going to go ahead and create a new file called george-washington.html, and we are going to write the response body to that file, so all of the data that we received from Wikipedia, and once we are done, this callback function will fire because we are using the asynchronous writeFile method.

Any errors will be passed as an argument to that function. If we have any errors, for this example I'm just going to throw them, so if an error does occur we will just throw it. Otherwise, we're going to go ahead and let you know that the file has been downloaded. All right. So in our HTTP request callback function, we receive the response object, so we're going to use that stream to gather all of the data chunks and we're going to concatenate our response body. Once we've received all of the data from Wikipedia, this end function will be invoked and we are going to write to file george-washington.html.

So the other thing that we want to do is, if you noticed we created a request object up here on line 11, something else that we can do is we can come down here to the end and we can finish working with our request object. We can actually wire up a listener for any errors. If an error occurs with our request, this function will fire. If there's a request error, our callback function will fire and that error will be passed to this function. If there are any errors, we're just going to go ahead and console.log and we'll use a string template, problem with request, and in this string template, we will just go ahead and show the error message.

The other thing is, is we have set up our request, we're wired up a listener for an error, we just also want to end our requests, so we're not going to add any more listeners to our request, we're not sending any more data with our request, so we're just going to go ahead and end that there. Sweet. So at this point, we should be making a request for George Washington's Wikipedia page, and we should be creating a new .html file. Let's go ahead and navigate to the terminal and let's run our app, node request. And when we do so, we see that the file has been downloaded, and you will also notice that we received all of these data chunks.

All of these data chunks represents a string and this is how long each of those strings are. These data chunks are being streamed to us over the internet, small bits at a time. I'm going to scroll all the way up here to where the request has started, so you can see we have quite a few data chunks that are actually coming with this file. When we get up here, if you actually take a look at this text here from !DOCTYPE html, all the way down to <script>window.RLQ, this represents the very first data chunk.

This is what each of these chunks look like. This very first data chunk has 377 characters and there are 377 text characters of HTML. This is what one chunk looks like, and all of these chunks are put together to make the full page. If we scroll up some more, we can also see that we have response headers, so we have an object literal that is giving us all of the response headers from Wikipedia. Finally, we also logged that the response has started well before we even began gathering chunks and that the server status was a 200, or successful, response.

Finally, if we navigate to our file system, we should have george-washington.html. So this is George Washington's Wikipedia page. Granted, we don't have any of the images working, because we are viewing this via the file API, but this is the HTML that we have downloaded. If you want to see this HTML in the browser, you can right click anywhere in the browser and go to View Page Source, and you can see that we have downloaded all of this HTML text in chunks and then concatenated those chunks back together to create a file.

So we can use the HTTP or HTTPS module to make requests of HTTP servers.